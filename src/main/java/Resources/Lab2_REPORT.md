# Laboratory Work 2: Stream ciphers and Block ciphers

## Stream Cipher: RC4

### Description

RC4 cipher is a stream cipher is known for its simplicity, and it's the kind of algorithm that is known
for encrypting data bit by bit. It is a symmetric key algorithm, which means that the same key is used
for both encryption and decryption. The algorithm is based on a permutation of 256 bytes, which is
called the S-box. The S-box is initialized with a key, and then it is used to encrypt the data. The
algorithm is very fast, and it is used in many applications, such as WEP, WPA, and WPA2.

### Implementation

As said before, the S-box is initialized with a key, and then it is used to encrypt the data. The
function that initializes the S-box is called keyArrayGen() and is called inside the process
of encryption or decryption of the message. The returns are the S-box, which is an array of 256 bytes. 

```java
public int[] keyArrayGen(){
        int[] S = new int[256];
        int[] keyToBytes = stringToBytes(this.permutationKey);

        for(int counter = 0; counter < 256; counter++){
            S[counter] = counter;
        }

        int j = 0;
        for(int counter = 0; counter < 256; counter++){
            j = (j + S[counter] + keyToBytes[counter % keyToBytes.length]) % 256;
            int tmp = S[counter];
            S[counter] = S[j];
            S[j] = tmp;
        }

        return S;
    }
```

Encryption and decryption are done in the same function, which is called processMessage(). The function
takes a string as a parameter, and it returns the encrypted/decrypted string. The function is called
in the main function, and it is called twice, once for encryption and once for decryption. The looks
like this:

```java
public String processMessage (String message){
        int[] S = keyArrayGen();
        int[] messageToBytes = stringToBytes(message);
        int[] processedMessageBytes = new int[message.length()];

        int i = 0, j = 0;
        for(int counter = 0; counter < message.length(); counter++){
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;

            int tmp = S[counter];
            S[counter] = S[j];
            S[j] = tmp;

            int k = S[(S[i] + S[j]) % 256];
            processedMessageBytes[counter] = messageToBytes[counter] ^ k;
        }

        return bytesToString(processedMessageBytes);
    }
```

The function of encryption and encryption based on the S-box follows a simple formula:

#$j = (j + S[i] + key[i mod key.length]) mod 256$

Where $i$ is the index of the byte in the S-box, and $j$ is the index of the byte in the key.
When $j$ is calculated the values of S[i] and S[j] are then swapped. This is done for every byte.

##Block Cipher: SDES

### Description

SDES is a block cipher that uses a 10-bit key to encrypt and decrypt 8-bit blocks of data.It is a
simplified version of Data Encryption Algorithm. It is a  symmetric key algorithm, which means that the same key 
is used for both encryption and decryption. The algorithm is based on a permutation of 10 bytes, which 
is called the key. The key is initialized with a key, and then it is used to encrypt the data. The algorithm 
is very fast, and it is used in many applications, such as WEP, WPA, and WPA2.

### Implementation

The SDES cipher is initialized with the key, and then it is used to encrypt the data. At the constructor
of the class, the first thing that is done is the permutation of both arrays P10 and P8. 

```java
public int[] permutation(int n){
        Integer[] arr = new Integer[n];
        for(int i = 0; i < n; i++){
        arr[i] = i+1;
        }
        List<Integer> intList = Arrays.asList(arr);
        Collections.shuffle(intList);
        intList.toArray(arr);

        int[] result = new int[n];
        for(int i = 0; i < n; i++){
        result[i] = intList.get(i);
        }

        return result;
}
```

After the permutations are done, the key is generated by calling the keyGen() function. The keyGen()
applies the permutation P10 to the key, and then it splits the array in two parts of 5 bytes. The keys
are then combined in a way that the first key is the first 5 bytes of the array, and the second key is
the last 5 bytes of the array. The keys are then applied to the permutation P8 which will make them
8 bytes long. The two halves from before will undergo another two-bit left shift, and then they will
be applied to the permutation P8 again. The final output of the function is an array of 2 keys, each
of them 8 bytes long.

```java
private int[][] keyGen(String key){
        for(int i = 0; i < 10; i++){
            this.permutationKeyArray[i] = key.charAt(P10[i] - 1);
        }

        int Ls[] = new int[5];
        int Rs[] = new int[5];
        int[] key1 = new int[8];
        int[] key2 = new int[8];

        for(int i = 0; i < 5; i++){
            Ls[i] = permutationKeyArray[i];
            Rs[i] = permutationKeyArray[i + 5];
        }

        int[] Ls_1 = shift(Ls, 1);
        int[] Rs_1 = shift(Rs, 1);

        for(int i = 0; i < 5; i++){
            permutationKeyArray[i] = Ls_1[i];
            permutationKeyArray[i + 5] = Rs_1[i];
        }

        for(int i = 0; i < 8; i++){
            key1[i] = permutationKeyArray[P8[i] - 1];
        }

        int[] Ls_2 = shift(Ls, 2);
        int[] Rs_2 = shift(Rs, 2);

        for(int i = 0; i < 5; i++){
            permutationKeyArray[i] = Ls_2[i];
            permutationKeyArray[i + 5] = Rs_2[i];
        }

        for(int i = 0; i < 8; i++){
            key2[i] = permutationKeyArray[P8[i] - 1];
        }

        return new int[][]{key1, key2};
}
```

Encryption code:

```java
public int[] encryptMessage(String message){
        int[] messageArray = new int[message.length()];
        for(int i = 0; i < messageArray.length; i++){
            messageArray[i] = message.charAt(i);
        }
        int[] arr = new int[8];

        int[] IP_ = permutation(8);
        for(int i = 0; i < 8; i++){
            this.IP[i] = IP_[i];
        }
        int[] IP_Inv_ = inversePermutation(this.IP, this.IP.length);
        for(int i = 0; i < 8; i++){
            this.IP_inv[i] = IP_Inv_[i];
        }

        for(int i = 0; i < 8; i++){
            arr[i] = messageArray[this.IP[i] - 1];
        }
        int[] arr1 = function_(arr, key1);

        int[] after_swap = swap(arr1, arr1.length / 2);

        int[] arr2 = function_(after_swap, key2);

        int[] ciphertext = new int[8];

        for(int i = 0; i < 8; i++){
            ciphertext[i] = arr2[IP_inv[i] - 1];
        }

        return ciphertext;
    }
```

When the key is generated, the encryption and decryption functions are called. The encryption function
is called encryptMessage(), and it takes a string as a parameter. The string is converted to bytes, and then
it is permuted using an initial permutation table (IP). The bytes are then split in two parts each with the length
of 4 bytes. The first part is called L, and the second part is called R.

These parts of the function are responsible for the initial permutation (IP) and the split of the message in two parts:
```java
int[] messageArray = new int[message.length()];
        for(int i = 0; i < messageArray.length; i++){
            messageArray[i] = message.charAt(i);
        }
        int[] arr = new int[8];

        int[] IP_ = permutation(8);
        for(int i = 0; i < 8; i++){
            this.IP[i] = IP_[i];
        }
        int[] IP_Inv_ = inversePermutation(this.IP, this.IP.length);
        for(int i = 0; i < 8; i++){
            this.IP_inv[i] = IP_Inv_[i];
        }

        for(int i = 0; i < 8; i++){
            arr[i] = messageArray[this.IP[i] - 1];
}
```
Found in function_():

```java
int[] l = new int[4];
int[] r = new int[4];

for(int i = 0; i < 4; i++){
    l[i] = ar[i];
    r[i] = ar[i + 4];
}
```

After both sides of the message were defined, inside the function_ (which does the encryption) the right side is then 
expanded using the EP table which will convert it from 4 bits to 8 bits long. 

```java
int[] ep = new int[8];
int[] leftSEP = permutation(4);
int[] rightSEP = permutation(4);
for(int i = 0; i < 4; i++){
    this.EP[i] = leftSEP[i];
}
for(int i = 4; i < 8; i++){
    this.EP[i] = rightSEP[i-4];
}

for(int i = 0; i < 8; i++){
    ep[i] = r[this.EP[i] - 1];
}
```

Then the expanded right side is XORed with the key. The result of the XOR is then split in two parts, each with the length of 4 bytes.

```java
for(int i = 0; i < 8; i++){
    ar[i] = key_[i] ^ ep[i];
}

int[] l_1 = new int[4];
int[] r_1 = new int[4];

for(int i = 0; i < 4; i++){
    l_1[i] = ar[i];
    r_1[i] = ar[i + 4];
}
```

Both sides of the XORed will be used for the S-Boxes. The first and fourth bit will be used as the row and the second and third
bit will be used as columns. 

```java
int row, col, val;

row = Integer.parseInt("" + l_1[0] + l_1[3], 2);
col = Integer.parseInt("" + l_1[1] + l_1[2], 2);
val = S0[row][col];
String str_l = binary_(val);

row = Integer.parseInt("" + r_1[0] + r_1[3], 2);
col = Integer.parseInt("" + r_1[1] + r_1[2], 2);
val = S1[row][col];
String str_r = binary_(val);
```

The result of the S-Boxes will be used as the input for the P4 table.

```java
int[] r_ = new int[4];
for(int i = 0; i < 2; i++){
    char c1 = str_l.charAt(i);
    char c2 = str_r.charAt(i);
    r_[i] = Character.getNumericValue(c1);
    r_[i + 2] = Character.getNumericValue(c2);
}
int[] r_p4 = new int[4];
int[] p4 = permutation(4);
for(int i = 0; i < 4; i++){
    r_p4[i] = r_[p4[i] - 1];
}
```
The result of the above P4 table is then XOR with the left side of the IP table.

```java
for(int i = 0; i < 4; i++){
    l[i] = l[i] ^ r_p4[i];
}
```

The results of both halves are then combined.

```java
int[] output = new int[8];
for(int i = 0; i < 4; i++){
    output[i] = l[i];
    output[i + 4] = r[i];
}
return output;
```

After the output is returned, encryption will continue. The output will be split in two parts, and the left side will be swapped with the right side.

```java
int[] swap(int[] array, int n){
    int[] l = new int[n];
    int[] r = new int[n];

    for(int i = 0; i < n; i++){
        l[i] = array[i];
        r[i] = array[i + n];
    }

    int[] output = new int[2 * n];
    for(int i = 0; i < n; i++){
        output[i] = r[i];
        output[i + n] = l[i];
    }

    return output;
}
```

After the output of the swap function, the same function_() that was described above will be called again on the output of the swap function.
The only difference is that the second key will be used. After the output of the second function_() is returned, the output will be permuted using the inverse of the initial permutation table (IP_inv).

```java
for(int i = 0; i < 8; i++){
    ciphertext[i] = arr2[IP_inv[i] - 1];
}
return ciphertext;
```

For the decryption part, the same steps will be followed, but the order of the keys will be reversed. The first key will be used for the second function_() and the second key will be used for the first function_(). 
The output of the second function_() will be swapped with the output of the first function_().

```java
public int[] decryptMessage(String message){
        int[] messageArray = new int[message.length()];
        for(int i = 0; i < messageArray.length; i++){
            messageArray[i] = message.charAt(i);
        }
        int[] arr = new int[8];

        for(int i = 0; i < 8; i++){
            arr[i] = messageArray[this.IP[i] - 1];
        }

        int[] arr1 = function_(arr, key2);

        int[] after_swap = swap(arr1, arr1.length / 2);

        int[] arr2 = function_(after_swap, key1);

        int[] decrypted = new int[8];

        for(int i = 0; i < 8; i++){
            decrypted[i] = arr2[IP_inv[i] - 1];
        }

        return decrypted;
    }
```